// gcc -Wall -Wextra -Werror -std=c11 -static-pie -o attack_tree attack_tree.c
#define _GNU_SOURCE
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

struct node {
    char content[0x40];
    void (*printer)(const char*, const char*);
    struct node* first_child;
    struct node* next;
};

static struct node* g_first_node = NULL;

static void read_line(char* ptr, size_t size) {
    size_t i = 0;
    while (i < size) {
        ssize_t x = read(0, ptr + i, 1);
        if (x < 0) {
            err(1, "read");
        } else if (x == 0) {
            break;
        }
        i += x;
        if (ptr[i - 1] == '\n') {
            ptr[i - 1] = 0;
            break;
        }
    }
}

static void or_print(const char* prefix, const char* buf) {
    int pl = strlen(prefix) ?: 1;
    printf("%*s (OR) %s\n", 2 * pl - 2, prefix, buf);
}

static void and_print(const char* prefix, const char* buf) {
    int pl = strlen(prefix) ?: 1;
    printf("%*s (AND) %s\n", 2 * pl - 2, prefix, buf);
}

static struct node* new_node(void) {
    struct node* node = calloc(1, sizeof(*node));
    if (!node) {
        return NULL;
    }
    printf("Node content: ");
    // TODO To wczyta 0x40, czyli o 1 znak za duzo?
    read_line(node->content, sizeof(node->content));
    printf("OR node (0) / AND node (1): ");
    int x = 0;
    scanf("%d", &x);
    if (x == 0) {
        node->printer = or_print;
    } else if (x == 1) {
        node->printer = and_print;
    } else {
        puts("Invalid type");
        free(node);
        node = NULL;
    }
    return node;
}

static struct node* get_node(void) {
    char buf[0x100] = { 0 };
    printf("Pick paragraph: ");
    // TODO wczytuje o 1 znak za duzo?
    // nie, bufor ma 256 a czytamy 100..
    read_line(buf, 100);
    char* ptr = buf;

    struct node* current = g_first_node;
    while (current) {
        char* next_dot = strchr(ptr, '.');
        if (!next_dot) {
            break;
        }

        unsigned long index = strtoul(ptr, NULL, 10);
        ptr = next_dot + 1;

        current = current->first_child;
        while (current && --index) {
            current = current->next;
        }
    }

    return current;
}

static void add_node(void) {
    struct node* parent = get_node();
    struct node* node = new_node();
    if (!node) {
        return;
    }

    if (!g_first_node) {
        g_first_node = node;
        return;
    }

    if (!parent) {
        puts("Invalid index");
        free(node);
        return;
    }

    struct node** prev = &parent->first_child;
    parent = parent->first_child;
    while (parent) {
        prev = &parent->next;
        parent = parent->next;
    }
    *prev = node;
}

static void edit_node(void) {
    struct node* node = get_node();
    if (!node) {
        puts("Invalid index");
        return;
    }

    printf("New content: ");
    // TODO może pozwolić wczytać za dużo
    read_line(node->content, strlen(node->content));
}

static void print_subtree(char* prefix, struct node* node) {
    size_t i = 1;
    char buf[0x40];

    while (node) {
        // TODO Tu mozna wyjsc mocno poza zakres bufora jak jest dlugi prefix
        sprintf(buf, "%s%zu.", prefix, i);
        // Gdyby content = /sh/bin
        // to dzieciak otrzyma prefix = /sh/bin i  potem buffer = /sh/bin1.
        node->printer(buf, node->content);
        printf("%4$p %5$p %6$p %7$p %8$p %9$p %10$p %11$p %12$p %13$p %14$p\n");
        print_subtree(buf, node->first_child);
        ++i;
        node = node->next;
    }
}

// TODO pomysł:
// 1. zleakować kanarka patrząc na to co wypisuje print_subtree?

// 1. wypisac wartosc "printer" - to da nam pozycje funkcji or_print
// 2. znalezc gdzie w pliku znajduje sie or_print - wtedy mozna znalezc
//    relatywne adresy wszystkich innych rzeczy
//    nadpisac printer czyms ciekawym
//    np. jakims ROPem?

static void print_tree(void) {
    puts("");
    if (!g_first_node) {
        return;
    }

    g_first_node->printer(".", g_first_node->content);

    puts("");

    print_subtree("", g_first_node->first_child);

    puts("\n");
}

static void print_menu(void) {
    puts("1. Add paragraph\n"
         "2. Edit paragraph\n"
         "3. Print tree\n"
         "4. Exit"
    );
}

int main(void) {
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);

    puts("Welcome to the Attack Tree Editor");

    while (1) {
        print_menu();
        int x = 0;
        switch (scanf("%d", &x)) {
            case 0:
                scanf("%*s");
                break;
            case EOF:
                return 0;
            default:
                break;
        }
        switch (x) {
            case 1:
                add_node();
                break;
            case 2:
                edit_node();
                break;
            case 3:
                print_tree();
                break;
            case 4:
                return 0;
            default:
                puts("Invalid option");
                break;
        }
    }
}
